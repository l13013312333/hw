<!DOCTYPE html>

<html>

<head>
<style>
#info {
  position: absolute;
  top: 0px;
  width: 100%;
  padding: 10px;
  text-align: center;
  color: #ffff00
}

body {
  // margin: 0;
  overflow: hidden;
}

.folder .dg ul {
  margin-top: 0 !important;
}


</style>
</head>

<body> 
<div id="info">CG_5
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.min.js"></script>
<script src="https://dl.dropboxusercontent.com/u/3587259/Code/Threejs/OrbitControls.js">
</script>
<script src="//cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
<script id="myVertexShader" type="x-shader/x-vertex">
  uniform int shading;
  uniform int coordinate;
	varying vec3 color;
  varying vec3 p;
	
  void perVertexShading() {
  	if(coordinate == 0) p = position;
    else if (coordinate == 1) p = vec3(modelMatrix * vec4(position, 1.0));
    else p = vec3(modelViewMatrix * vec4(position, 1.0));
  	
  	if (p.x > 0.0) 
    	color = vec3 (1,1,1);
    else
    	color = vec3 (0,0,0);
  }
	void perPixelShading() {
  	if(coordinate == 0)	p = position;
    else if(coordinate == 1) p = vec3(modelMatrix * vec4(position, 1.0));
    else p = vec3(modelViewMatrix * vec4(position, 1.0));
  }
	void main() {
		gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0);
  	if (shading == 0)  // per-vertex shading
    	perVertexShading();
    else
    	perPixelShading();
  }
</script>
<script id="myFragmentShader" type="x-shader/x-fragment">
  varying vec3 color;
	uniform int shading;
  uniform int coordinate;
  varying vec3 p;
  
  void main() {
    if(shading == 0) gl_FragColor = vec4 (color, 1.0);
    else{
    	if(p.x > 0.0) gl_FragColor = vec4 (1, 1, 1, 1.0);
    	else gl_FragColor = vec4 (0, 0, 0, 0.0);
    }
	}
</script>

<script>
var camera, scene, renderer, lamp, light, controls;
var tea, tea2, angle = 0;
var G;

init();
animate();

function init() {
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
  camera.position.y = 20;
  camera.position.z = 100;
  scene.add(camera);

  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x333333);

  controls = new THREE.OrbitControls(camera, renderer.domElement);

  document.body.appendChild(renderer.domElement);
  ///////////////////////////////////////////////////////////Loader
  teapotMaterial = new THREE.ShaderMaterial({
    uniforms: {
      lightpos: {type: 'v3', value: new THREE.Vector3(0, 30, 20) },
			shading: {type: 'i', value: 0},
      coordinate: {type: 'i', value: 0},
		},
    vertexShader: document.getElementById('myVertexShader').textContent,
    fragmentShader: document.getElementById('myFragmentShader').textContent
  });
  var loader = new THREE.JSONLoader();	loader.load("http://l13013312333.github.io/hw/modles/teapot.json",function(geometry, materials) {
  	var material = new THREE.MeshPhongMaterial(materials);
  	tea = new THREE.Mesh(geometry, material);
  	tea.scale.set(5, 5, 5);
    tea.castShadow = true;
    tea.receiveShadow = true;
  	scene.add(tea);
    
    tea2 = new THREE.Mesh(geometry, teapotMaterial);
    tea2.scale.set(5, 5, 5);
    tea2.castShadow = true;
    tea.receiveShoadow = true;
    tea2.position.set(50, 0, 0);
    scene.add(tea2);
  
	});
 //////////////////////////////////////////////////////////ELWE(Light, floor)
  // floor
  var floor = new THREE.Mesh(new THREE.PlaneGeometry(400, 400, 130, 130),
    new THREE.MeshLambertMaterial());
  floor.rotation.x = -Math.PI / 2;
  scene.add(floor);
 
  // spotlight
  light1 = new THREE.SpotLight(0xffffff, 1.5);
  light1.position.set(150, 150, 0);
  light1.angle = Math.PI/4;
  light1.exponent = 10;
  //light1.target = tea;
  scene.add(light1);

  // shadow map settings
  light1.castShadow = true;
  light1.shadowMapWidth = 1024;
  light1.shadowMapHeight = 1024;
  light1.shadowCameraNear = 10;
  light1.shadowCameraFar = 4000;
  light1.shadowCameraFov = light1.angle / Math.PI * 180;
  
  renderer.shadowMapEnabled = true;
  renderer.shadowMapType = THREE.PCFShadowMap;
  floor.receiveShadow = true;
  /////////////////////////////////////////////////////GUI
  G = new function() {
    this.shading = 'per-vertex';
    this.coordinate = 'object';
  }

  var gui = new dat.GUI();
  gui.domElement.id = 'gui';
  gui.add (G, 'coordinate', ['object', 'world', 'eye']).listen();
  gui.add (G, 'shading', ['per-vertex', 'per-pixel']).listen();
/////////////////////////////////////////////////////////
}
function animate() {
  angle += 0.01;
  
  if (tea2 !== undefined) {
		tea2.position.set (50*Math.cos(angle), 0, 50*Math.sin(angle));
  }
  
  if(G.coordinate == "object") teapotMaterial.uniforms.coordinate.value = 0;
  else if(G.coordinate == "world") teapotMaterial.uniforms.coordinate.value = 1;
  else teapotMaterial.uniforms.coordinate.value = 2;
  if(G.shading == "per-vertex") teapotMaterial.uniforms.shading.value = 0;
  else teapotMaterial.uniforms.shading.value = 1;
  
  
  
	controls.update();
  requestAnimationFrame(animate);
  render();
}

function render() {
  renderer.render(scene, camera);
}

</script>
</body>

</html>
