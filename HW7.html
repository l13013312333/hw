<!DOCTYPE html>

<html>

<head>
<style>
body {
    background-color: #fff;
    color: #111;
    margin: 0px;
    overflow: hidden;
    font-family: Monospace;
    font-size: 10px;
    position: absolute;
}
#info {
    position: absolute;
    top: 3%;
    width: 100%;
    padding: 5px;
    text-align: center;
    color: #ffff00
}
#gui {
    position: absolute;
    top: 10px;
    right: 10px;
    height: 350px;
}
</style>
</head>

<body> 
<div id="info">CG_HW7
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r76/three.min.js"></script>
<script src="https://dl.dropboxusercontent.com/u/3587259/Code/Threejs/OrbitControls.js">
</script>

<script src="//cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5/dat.gui.min.js"></script>
    
<script id="myVertexShader" type="x-shader/x-vertex">
	varying vec2 vUv;
	void main() {
		gl_Position = projectionMatrix* modelViewMatrix * vec4( position, 1.0);
		vUv = uv;
	}
</script>
<script id="myFragmentShader" type="x-shader/x-fragment">
	uniform sampler2D texture;
	varying vec2 vUv;
  uniform float fade;
vec3 rgb2hsv(vec3 c)
{
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}	
	void main() {
		vec4 color = texture2D (texture, vUv);
    vec3 hsv = rgb2hsv (color.rgb);
    hsv.y = fade;
    vec3 rgb = hsv2rgb (hsv.xyz);
	gl_FragColor = vec4 (rgb, 1.0);
	}
</script>


<script>

var renderer, camera, controls;
var pointLight;
var sceneCanvas, sceneMono, sceneColor;
var camera2;
var rtTexture;
var torus, torus1, torus2, torus3, torus4;
var gcontrols;

// blocker pass
// 1st pass: torus (colorWrite off)
// 2nd pass: column

init();
animate();

function init()
{
	//渲染像素
	rtTexture = new THREE.WebGLRenderTarget( 
		1024,1024,
		{ minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBFormat } 
		);

	renderer = new THREE.WebGLRenderer({antialias: true});
	renderer.setSize (window.innerWidth, window.innerHeight);
	document.body.appendChild (renderer.domElement);
	renderer.setClearColor (0x888888);
	renderer.autoClear = false;
  
	camera = new THREE.PerspectiveCamera (45, window.innerWidth/window.innerHeight, 0.1, 10000);
	camera.position.y = 0;
	camera.position.z = 400;
	camera.lookAt (new THREE.Vector3(0,0,0));

	controls = new THREE.OrbitControls (camera, renderer.domElement);
///////////////////////////////////////////////////////////////////////
	//第一幕:背景+圈圈處理
	sceneMono = new THREE.Scene();	
	pointLight = new THREE.PointLight (0xffffff, 1.0);
	pointLight.position.set (0,200,500);
	sceneMono.add (pointLight);
	
  
	torus = new THREE.Mesh (new THREE.TorusGeometry(10, 3, 16, 100),
	new THREE.MeshLambertMaterial({color:0x12ffee, 
  colorWrite:false
  }));
	torus.scale.set (3,3,3);
  torus.rotation.x = Math.PI/2;
	sceneMono.add (torus);
  
  torus1 = new THREE.Mesh (new THREE.TorusGeometry(10, 3, 16, 100),
	new THREE.MeshLambertMaterial({color:0x12ffee, 
  colorWrite:false
  }));
	torus1.scale.set (3,3,3);
  torus1.position.set(Math.random()*200-100, Math.random()*200-100, Math.random()*200-100);
  torus1.rotation.set(Math.PI/Math.random()*8-0, Math.PI/Math.random()*8-0, Math.PI/Math.random()*8-0);
	sceneMono.add (torus1);
  
  torus2 = new THREE.Mesh (new THREE.TorusGeometry(10, 3, 16, 100),
	new THREE.MeshLambertMaterial({color:0x12ffee, 
  colorWrite:false
  }));
	torus2.scale.set (3,3,3);
  torus2.position.set(Math.random()*200-100, Math.random()*200-100, Math.random()*200-100);
  torus2  .rotation.set(Math.PI/Math.random()*8-0, Math.PI/Math.random()*8-0, Math.PI/Math.random()*8-0);
	sceneMono.add (torus2);
  
  torus3 = new THREE.Mesh (new THREE.TorusGeometry(10, 3, 16, 100),
	new THREE.MeshLambertMaterial({color:0x12ffee, 
  colorWrite:false
  }));
	torus3.scale.set (3,3,3);
  torus3.position.set(Math.random()*200-100, Math.random()*200-100, Math.random()*200-100);
  torus3.rotation.set(Math.PI/Math.random()*8-0, Math.PI/Math.random()*8-0, Math.PI/Math.random()*8-0);
	sceneMono.add (torus3);
  
  torus4 = new THREE.Mesh (new THREE.TorusGeometry(10, 3, 16, 100),
	new THREE.MeshLambertMaterial({color:0x12ffee, 
  colorWrite:false
  }));
	torus4.scale.set (3,3,3);
  torus4.position.set(Math.random()*200-100, Math.random()*200-100, Math.random()*200-100);
  torus4.rotation.set(Math.PI/Math.random()*8-0, Math.PI/Math.random()*8-0, Math.PI/Math.random()*8-0);
	sceneMono.add (torus4);
    
    /////////////////////////////////////////////////////
    gcontrols = {
        fade: 2.0,
    };
    
    var gui = new dat.GUI();
    gui.domElement.id = 'gui';
    
    gui.add(gcontrols, 'fade', 0.1, 5.0);
    
    gcontrols.onchange = function () {
     console.log ('pp');
    	//console.log (gcontrols.fade);
    }
    
    //第二幕:方塊獨角
  sceneColor = new THREE.Scene();
	var column = new THREE.Mesh (new THREE.BoxGeometry (20,50,20),
  new THREE.MeshLambertMaterial({color:0xff1234}));
  //sceneColor.add (pointLight);  
  // same light cannot be added to two scenes
	var pointLight2 = new THREE.PointLight (0xffffff, 1.0);
	pointLight2.position.set (0,200,500);
  sceneColor.add (pointLight2);
  sceneColor.add (column);

	
	sceneCanvas = new THREE.Scene();
  camera2 = new THREE.OrthographicCamera (-10,10,10,-10, -10,100);
  camera2.position.z = 5;
  monochromeMat = new THREE.ShaderMaterial ({
	  uniforms: {
		  texture: {type: 't', value: rtTexture},
      fade:{type:'f', value:2.0}
	  },
		vertexShader: document.getElementById('myVertexShader').textContent,
		fragmentShader: document.getElementById('myFragmentShader').textContent,
  });
	monochromeMat.depthWrite = false;
  
  var plane = new THREE.Mesh (new THREE.PlaneGeometry(20,20), monochromeMat);
  sceneCanvas.add (plane);
}

window.onresize = function () {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize (window.innerWidth, window.innerHeight);
}

function animate()
{
	controls.update();
	monochromeMat.uniforms.fade.value = gcontrols.fade;
	requestAnimationFrame ( animate );
	renderer.clear();
  
 	renderer.setClearColor (0x888800);
  
	// turn colorWrite true
  torus.material.colorWrite = true;
  torus1.material.colorWrite = true;
  torus2.material.colorWrite = true;
  torus3.material.colorWrite = true;
  torus4.material.colorWrite = true;
	renderer.render (sceneMono, camera, rtTexture, true);
 	renderer.setClearColor (0x888888);
	renderer.render (sceneCanvas, camera2);
  
  torus.material.colorWrite = false;
  torus1.material.colorWrite = false;
  torus2.material.colorWrite = false;
  torus3.material.colorWrite = false;
  torus4.material.colorWrite = false;
	renderer.render (sceneMono, camera);  // set up depth buffer
	renderer.render (sceneColor, camera);

}


</script>
</body>

</html>
