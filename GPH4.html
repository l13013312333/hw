<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js"></script>
<script src="https://rawgit.com/jyunming-chen/tutsplus/master/js/text2D.js"></script>
<script src="https://dl.dropboxusercontent.com/u/3587259/Code/Threejs/OrbitControls.js">


</script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>

    <style>
      body {
      	margin: 0;
      	overflow: hidden;
      }
      .top {
      	position: absolute;
      	width: 100%;
      	padding: 10px;
      	text-align: center;
      	top: 1em;
      	color: yellow;
      }
    </style>
  </head>
  <body>
    <div class='top'>GP_HW4</div>
    <script>
      var camera, scene, renderer, controls;
var puck, raycaster, intersects;
var agents = [];
var pickable = [];
var angle = 0;
var obRad = 30, obRad2 = 20, obRad3 = 10;
var targetCatch = false;
var targetOmega = 0.3;
var obCen = new THREE.Vector3();
var obCen2 = new THREE.Vector3(70, 0, -40);
var obCen3 = new THREE.Vector3(-60, 0, -20);
var mass = 1;
var clock = new THREE.Clock();
var mouse = new THREE.Vector2();
var target = new THREE.Vector3();
var SpriteText2D = THREE_Text.SpriteText2D;
var textAlign = THREE_Text.textAlign;


var Agent = function(mesh, initPos) {
  this.pos = new THREE.Vector3();
  if (initPos) this.pos.copy(initPos);
	this.name = name;
  this.nbhd = [];
  this.vel = new THREE.Vector3();
  this.force = new THREE.Vector3();
  this.target = new THREE.Vector3();
  this.angle = 0
  scene.add(this.mesh = mesh.clone());
  this.maxSpeed = 50;
  this.maxForce = 50;

  this.setTarget = function(target) {
    this.target.copy(target);
  }
  
  var text = new SpriteText2D("", {
  	align: textAlign.center,
    font: '10px Courier',
    fillStyle: '#000000',
    antialias:true,
  });
  scene.add(text);
  text.position.set(this.pos.x, 20, this.pos.z);
  this.update = function(dt) {
  
  text.position.set(this.pos.x, 20, this.pos.z);
  
    // compute force
    this.force = this.target.clone().sub(this.pos).setLength(this.maxSpeed).sub(this.vel);
    
    // collision avoidance
    var tmp = obCen.clone().sub(this.pos);
    var tmpProj = tmp.clone().projectOnVector(this.vel);
    if (tmp.dot(this.vel) > 0) {
    	if (tmpProj.clone().sub(tmp).length() < obRad + 10) {
      	
      	if (tmpProj.length() < 5 *this.vel.length()) {
    			this.force.add (tmpProj.clone().sub(tmp).multiplyScalar(200));    	
        }
      }
    }  
    //***********
    var tmp2 = obCen2.clone().sub(this.pos);
    var tmpProj2 = tmp2.clone().projectOnVector(this.vel);
    if (tmp2.dot(this.vel) > 0) {
    	if (tmpProj2.clone().sub(tmp2).length() < obRad2 + 10) {
      	
      	if (tmpProj2.length() < 5 *this.vel.length()) {
    			this.force.add (tmpProj2.clone().sub(tmp2).multiplyScalar(200));   
          }
      }
    }  
    //***********
    var tmp3 = obCen3.clone().sub(this.pos);
    var tmpProj3 = tmp3.clone().projectOnVector(this.vel);
    if (tmp3.dot(this.vel) > 0) {
    	if (tmpProj3.clone().sub(tmp3).length() < obRad3 + 20) {
      	
      	if (tmpProj3.length() < 5 *this.vel.length()) {
    			this.force.add (tmpProj3.clone().sub(tmp3).multiplyScalar(200));    	
        }
      }
    }  
    
    // force clamping
    if (this.force.length() > this.maxForce)
      this.force.setLength(this.maxForce);
    this.vel.add(this.force.clone().multiplyScalar(dt));

    // velocity clamping
    if (this.vel.length() > this.maxSpeed)
      this.vel.setLength(this.maxSpeed);
    this.pos.add(this.vel.clone().multiplyScalar(dt));

    if (this.vel.length() > 0.001) {
      this.angle = Math.atan2(-this.vel.z, this.vel.x);
    }
    this.mesh.position.copy(this.pos);
    this.mesh.rotation.y = this.angle;

    // catch handling
    if (this.pos.distanceTo(this.target) < 2) {
      this.vel.set(0, 0, 0);
      angle = Math.random() * Math.PI * 2;
      text.text = "抓到了!";
	  clock.stop;
	  setTimeout("location.href = 'http://www.google.com.tw'", 100);
		}
    else {
    	text.text="追";
    }

  }
}

init();
animate();

function init() {
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
  camera.position.y = 300;
  scene.add(camera);

   var gridXZ = new THREE.GridHelper(100, 10, 'red', 'white');
  scene.add(gridXZ);
  
  var floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshBasicMaterial({visible:false}));
  floor.rotation.x = -Math.PI/2;
  pickable.push(floor);
  scene.add(floor);

  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x888888);

  controls = new THREE.OrbitControls(camera, renderer.domElement);
  raycaster = new THREE.Raycaster();
  document.body.appendChild(renderer.domElement);
  window.addEventListener('resize', onWindowResize, false);
  window.addEventListener('mousedown', onMouseDown, false);
  renderer.domElement.addEventListener('mousemove', onMouseMove, false);

  //////////////////////
  
  var ob = new THREE.Mesh (new THREE.CircleGeometry (obRad,20));
  ob.rotation.x = -Math.PI/2;
  scene.add (ob);
  
  var ob2 = new THREE.Mesh (new THREE.CircleGeometry (obRad2,20));
  ob2.position.set(70, 0, -40);
  ob2.rotation.x = -Math.PI/2;
  scene.add (ob2);
  
  var ob3 = new THREE.Mesh (new THREE.CircleGeometry (obRad3,20));
  ob3.position.set(-60, 0, -20);
  ob3.rotation.x = -Math.PI/2;
  scene.add (ob3);

  var geometry = new THREE.BoxGeometry(15, 2, 5);
  var material = new THREE.MeshNormalMaterial();
  var box = new THREE.Mesh(geometry, material);
  //scene.add(box);
  
  agents.push(new Agent(box, new THREE.Vector3(Math.random()*200-100, 0, Math.random()*200-100)));
  agents.push(new Agent(box, new THREE.Vector3(Math.random()*200-100, 0, Math.random()*200-100)));
  agents.push(new Agent(box, new THREE.Vector3(Math.random()*200-100, 0, Math.random()*200-100)));
  agents.push(new Agent(box, new THREE.Vector3(Math.random()*200-100, 0, Math.random()*200-100)));
  agents.push(new Agent(box, new THREE.Vector3(Math.random()*200-100, 0, Math.random()*200-100)));
  agents.push(new Agent(box, new THREE.Vector3(Math.random()*200-100, 0, Math.random()*200-100)));
  agents.push(new Agent(box, new THREE.Vector3(Math.random()*200-100, 0, Math.random()*200-100)));
  agents.push(new Agent(box, new THREE.Vector3(Math.random()*200-100, 0, Math.random()*200-100)));

  puck = new THREE.Mesh(new THREE.CylinderGeometry(4, 4, 2, 20), new THREE.MeshBasicMaterial());
  scene.add(puck);
  }

function animate() {
  var dt = clock.getDelta();
  
  for(i = 0; i < agents.length; i++){
  	agents[i].update(dt);
    agents[i].setTarget(target);
  }
  
  controls.update();
  requestAnimationFrame(animate);
  render();
}

function onMouseDown(event) {
	event.preventDefault();
	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
  if(intersects.length>0) target.copy(intersects[0].point);
 	puck.position.copy(target);
}

function onMouseMove(event){
	event.preventDefault();
	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
	
    raycaster.setFromCamera( mouse, camera );	
    
    intersects = raycaster.intersectObjects( pickable );

}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function render() {
  renderer.render(scene, camera);
}
window.focus();
    </script>
  </body>
</html>