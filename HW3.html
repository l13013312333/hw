<!DOCTYPE html>

<html>

<head>
<style>
body {
    overflow: hidden;
}
#up{
  position: absolute;
  top: 465px;
  right: 50px;
  opacity:1;
  filter:alpha(opacity=100); 
}
#down{
  position: absolute;
  top: 500px;
  right: 50px;
  opacity:1;
  filter:alpha(opacity=100); 
}
#right{
  position: absolute;
  top: 500px;
  right: 15px;
  opacity:1;
  filter:alpha(opacity=100); 
}
#left{
  position: absolute;
  top: 500px;
  right: 85px;
  opacity:1;
  filter:alpha(opacity=100); 
}


</style>
</head>

<body> 
<img id = "up" src="http://i.imgur.com/hMrI78Z.jpg" width="30" height="30"/>
<img id = "down" src="http://i.imgur.com/nMLRV7A.jpg" width="30" height="30" />
<img id = "right" src="http://i.imgur.com/Huts8bE.jpg" width="30" height="30" />
<img id = "left" src="http://i.imgur.com/LjqLRho.jpg" width="30" height="30" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.min.js"></script>
<script src="https://dl.dropboxusercontent.com/u/3587259/Code/Threejs/OrbitControls.js">
</script>
<script src="http://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>

<script>
var camera, scene, renderer;
var car = new THREE.Object3D();
var fwire, speed = 0, ro = 0.01;
var keyboard = new KeyboardState();
var clock = new THREE.Clock();
var move = 0;
var C, RC, sum = 0;
var cylinder, cyl2, cyl3;

init();
animate();

function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
    scene.add(camera);

    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x888888);

    controls = new THREE.OrbitControls(camera, renderer.domElement);

    document.body.appendChild(renderer.domElement);
    window.addEventListener('resize', onWindowResize, false);
    document.addEventListener("keydown", this._onKeyDown, false);
		document.addEventListener("keyup", this._onKeyUp, false);
    
    var light = new THREE.PointLight(0xffffff, 1);
  light.position.set(150, 100, 120);
  scene.add(light);
  
  var light2 = new THREE.PointLight(0xffffff, 1);
  light.position.set(-150, 100, -120);
  scene.add(light);
  
  THREE.ImageUtils.crossOrigin = '';
    var floorTexture = THREE.ImageUtils.loadTexture('http://i.imgur.com/lj37xrW.png');
    floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;

    var floorMaterial = new THREE.MeshBasicMaterial({
        map: floorTexture,
        side: THREE.DoubleSide
    });

    var floorGeometry = new THREE.PlaneGeometry(200, 200, 10, 10);
    var floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.position.y = -0.5;
    floor.rotation.x = Math.PI / 2;
    scene.add(floor);
    //////////////////////////////////////////////////////////////
    
    //車子//
    	//車身
    var carbody = new THREE.Mesh(new THREE.BoxGeometry(20, 16, 40), new THREE.MeshLambertMaterial({
    color: 0x6abeb9, 
    transparent: true,
    opacity: 0.6
} ));
		carbody.position.set(0, 13, 0);
    car.add(carbody);
    
    	//後輪子*2
    var backw = new THREE.Mesh(new THREE.CylinderGeometry(5, 5, 2, 32), new THREE.MeshLambertMaterial());
    backw.rotation.z = Math.PI/2;
    var backw2 = backw.clone();
    backw.position.set(7, 5, -13);
    backw2.position.set(-7, 5, -13);
    car.add(backw);
    car.add(backw2);
    
      //前輪子
    fwire = backw.clone();
    fwire.position.set(0, 5, 13);
    car.add(fwire);
		scene.add(car);
    
    //////////////////////////////////////////柱子
    
    cylinder = new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 50, 20), new THREE.MeshLambertMaterial({color: 0x123456}));
    scene.add(cylinder);
    cylinder.position.set(-50, 25, -50);

    cyl2 = new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 50, 20), new THREE.MeshLambertMaterial({color: 0x123456}));
    cyl2.position.set(30, 25, 80);
    scene.add(cyl2);
    cyl3 = new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 50, 20), new THREE.MeshLambertMaterial({color: 0x123456}));
    cyl3.position.set(70, 25, -20);
    scene.add(cyl3);

}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
	
	controls.update();
  keyboard.update();
  camera.position.copy(car.localToWorld(new THREE.Vector3(0, 50, -80)));  
  camera.lookAt(car.localToWorld(new THREE.Vector3(0, 25, -20)));
  
  ////////////////////////////////////碰撞反應
  touch(cylinder);
  touch(cyl2);
  touch(cyl3);
  
  ////////////////////////////////////////////////////鍵盤控制
  
  var delta = clock.getDelta();
  
  document.getElementById("up").src="http://i.imgur.com/hMrI78Z.jpg"
  document.getElementById("down").src="http://i.imgur.com/nMLRV7A.jpg"
  document.getElementById("right").src="http://i.imgur.com/Huts8bE.jpg"
  document.getElementById("left").src="http://i.imgur.com/LjqLRho.jpg"
  
	if ( keyboard.pressed("up") ) {
  	if(speed < 1) speed += 0.1;
    move = 1;
    document.getElementById("up").src="http://i.imgur.com/ASRwYbd.jpg"
  }
	if ( keyboard.pressed("down") ) {
  	if(speed > -1) speed -= 0.1;
    move = -1;
    document.getElementById("down").src="http://i.imgur.com/1Z3i4fC.jpg"
  }
	if ( keyboard.pressed("right") ) {
  	if(ro > -Math.PI / 3) ro -= delta;
    else ro = -Math.PI / 3;
  	fwire.rotation.y = ro;
    document.getElementById("right").src="http://i.imgur.com/Rp0U7uF.jpg"
  }
	if ( keyboard.pressed("left") ) {
  	if(ro < Math.PI / 3) ro += delta;
    else ro = Math.PI / 3;
  	fwire.rotation.y = ro;
    document.getElementById("left").src="http://i.imgur.com/h1CLIi3.jpg"
  }
  if ( keyboard.pressed("space") ) {
  	move = 0;
    speed = 0;
  };
  ////////////////////////////////////////////////////角度計算
  
  var RO = (ro > 0)? 1 : -1;
  var L = 24 / Math.tan(ro);//L = 24/tan()
  var omega = speed * Math.tan(ro) / L ;
  
  C = car.localToWorld(new THREE.Vector3(0, 0, 0));//中心點
  RC = car.localToWorld(new THREE.Vector3(-24/Math.tan(ro), 0, -12));
  
  var r = C.clone().sub(RC).length();
  var OME = -speed * Math.tan(-ro);
  var OMG = -speed * Math.tan(ro);
  var CC = C.clone().sub(RC).applyAxisAngle (new THREE.Vector3(0,1,0), OMG * delta);
  
  sum += OME * delta;
  car.position.copy(CC.add(RC));
  car.rotation.y = sum;
  
  
  ////////////////////////////////////////////////////////
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
function touch(cylinder){
	var rect = {};
    rect.max = car.position.clone().add (new THREE.Vector3(10,0,20));
    rect.min = car.position.clone().sub (new THREE.Vector3(10,0,20));

    var circ = {};
    circ.c = cylinder.position.clone();
    circ.r = 10;
  	var hit = checkIntersect (rect, circ);
		if (hit) {
    	speed = 0;
      cylinder.material.color.set('red');
    } else {
    	cylinder.material.color.set(0x123456);
    }
    
}

function checkIntersect(rect, circle) {
  var rad2 = circle.r * circle.r;
  var max = rect.max.clone().sub(circle.c);
  var min = rect.min.clone().sub(circle.c);
  
  if (max.x < 0) {
  	if (max.z < 0)
    	return (max.x*max.x + max.z*max.z < rad2);
    else if (min.z > 0)
    	return (max.x*max.x + min.z*min.z < rad2);
    else
    	return (Math.abs(max.x) < circle.r);
  } else if (min.x > 0) {
  	if (max.z < 0)
    	return (min.x*min.x + max.z*max.z < rad2);
    else if (min.z > 0)
    	return (min.x*min.x + min.z*min.z < rad2);
    else
    	return (min.x < circle.r);
  } else {
  	if (max.z < 0)
    	return (Math.abs(max.z) < circle.r);
    else if (min.z > 0)
    	return (min.z < circle.r);
    else
    	return true;
  }
}
window.focus();
</script>
</body>

</html>
